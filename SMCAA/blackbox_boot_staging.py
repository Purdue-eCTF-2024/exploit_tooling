import argparse
import serial
import re
from loguru import logger
import sys


NONCE = ""
SIGNATURE = ""
STAGE = 1


# Logger formatting
fmt = (
    "<green>{time:YYYY-MM-DD HH:mm:ss.SSS}</green> | "
    "{extra[extra]: <6} | "
    "<level>{level: <8}</level> | "
    "<level>{message}</level> "
)

logger.remove(0)
logger.add(sys.stdout, format=fmt)

def blackbox_boot_1(args):
    ser = serial.Serial(
        port=args.application_processor,
        baudrate=115200,
        parity=serial.PARITY_NONE,
        stopbits=serial.STOPBITS_ONE,
        bytesize=serial.EIGHTBITS,
    )

    # Arguments passed to the AP
    input_list = [
        "blackbox_boot_1\r"
    ]

    # Send and receive messages until done
    message = input_list.pop(0)
    ser.write(message.encode())
    logger.bind(extra="INPUT").debug(message)
    output = ""
    while True:
        byte = ser.read()
        char = byte.decode("utf-8")
        output += char
        output = process_output(output, input_list, ser)


def blackbox_boot_2(args):
    ser = serial.Serial(
        port=args.application_processor,
        baudrate=115200,
        parity=serial.PARITY_NONE,
        stopbits=serial.STOPBITS_ONE,
        bytesize=serial.EIGHTBITS,
    )

    # Arguments passed to the AP
    input_list = [
        "blackbox_boot_2\r",
        f"{NONCE}\r",
    ]

    # Send and receive messages until done
    message = input_list.pop(0)
    ser.write(message.encode())
    logger.bind(extra="INPUT").debug(message)
    output = ""
    while True:
        byte = ser.read()
        char = byte.decode("utf-8")
        output += char
        output = process_output(output, input_list, ser)


def blackbox_boot_3(args):
    ser = serial.Serial(
        port=args.application_processor,
        baudrate=115200,
        parity=serial.PARITY_NONE,
        stopbits=serial.STOPBITS_ONE,
        bytesize=serial.EIGHTBITS,
    )

    # Arguments passed to the AP
    input_list = [
        "blackbox_boot_3\r",
        f"{SIGNATURE}\r"
    ]

    # Send and receive messages until done
    message = input_list.pop(0)
    ser.write(message.encode())
    logger.bind(extra="INPUT").debug(message)
    output = ""
    while True:
        byte = ser.read()
        char = byte.decode("utf-8")
        output += char
        output = process_output(output, input_list, ser)


def process_output(output):
    # Find INFO level messages
    match = re.search("%info: ((.|\n|\r)*?)%", output)
    if match != None:
        # Output all of the data and remove from buffer
        output = output[:match.start()] + output[match.end():]
        for line in match.group(1).strip().split('\n'):
            logger.bind(extra="OUTPUT").info(line.strip())
    # Find DEBUG level messages
    match = re.search("%debug: ((.|\n|\r)*?)%", output)
    if match != None:
        # Output all of the data and remove from buffer
        output = output[:match.start()] + output[match.end():]
        for line in match.group(1).strip().split('\n'):
            logger.bind(extra="OUTPUT").debug(line.strip())
    # Find ACK level messages
    match = re.search("%ack%", output)
    if match != None:
        # Ignore
        output = output[:match.start()] + output[match.end():]
    # Find SUCCESS level messages
    match = re.search("%success: ((.|\n|\r)*?)%", output)
    if match != None:
        # Output all of the data and remove from buffer
        output = output[:match.start()] + output[match.end():]
        for line in match.group(1).strip().split('\n'):
            logger.bind(extra="OUTPUT").success(line.strip())
        exit(0)
    # Find ERROR level messages
    match = re.search("%error: ((.|\n|\r)*?)%", output)
    if match != None:
        # Output all of the data and remove from buffer
        output = output[:match.start()] + output[match.end():]
        for line in match.group(1).strip().split('\n'):
            logger.bind(extra="OUTPUT").error(line.strip())
        exit(1)
    # Return the spliced output
    return output


# Main function
def main():
    parser = argparse.ArgumentParser(
        prog="eCTF Boot Host Tool", description="Blackbox Boot Attack"
    )

    parser.add_argument(
        "-a", "--application-processor", required=True, help="Serial device of the AP"
    )

    args = parser.parse_args()

    if STAGE == 1:
        blackbox_boot_1()
    elif STAGE == 2:
        blackbox_boot_2()
    elif STAGE == 3:
        blackbox_boot_3()

if __name__ == "__main__":
    main()

