The reference design contains an interrupt handler on the component to enable asynchrnous receiving of i2c message.
The reference design interrupt handler has the concept of registers, where some registers are longer than others.
The send and receive data registers are 255 bytes long, but the send and receive lenght and done registers are only 1 byte long.

We exploited a flaw in the component interrupt handler. What we did is start a transaction to send data to the component.
We sent 6 bytes, and selected the recieve register, which is a large register of 255 bytes. This caused the WRITE_INDEX
variable to be incramented by 5 (since 1 byte was used to select the register). The reason we sent 6 bytes
was to trigger a recieve threshhold interrupt, which is triggered when 6 bytes are in the fxfifo.
The code for recieving bytes can be seen below:

```
int available = MXC_I2C_GetRXFIFOAvailable(I2C_INTERFACE);
if (available < (I2C_REGS_LEN[ACTIVE_REG]-WRITE_INDEX)) {
    WRITE_INDEX += MXC_I2C_ReadRXFIFO(I2C_INTERFACE,
        &I2C_REGS[ACTIVE_REG][WRITE_INDEX],
        MXC_I2C_GetRXFIFOAvailable(I2C_INTERFACE));
}
else {
    WRITE_INDEX += MXC_I2C_ReadRXFIFO(I2C_INTERFACE,
        &I2C_REGS[ACTIVE_REG][WRITE_INDEX],
        I2C_REGS_LEN[ACTIVE_REG]-WRITE_INDEX);
}
```

Since 5 data bytes were read in, this will cause WRITE_INDEX to be incramented to 5. There is an issue however,
since if `WRITE_INDEX > I2C_REGS_LEN[ACTIVE_REG]`, this will trigger the else clause to run, and
`I2C_REGS_LEN[ACTIVE_REG]-WRITE_INDEX` will be a negative number, and when passed into MXC_I2C_ReadRXFIFO as the length argument,
it will get cast to a very large unsigned value, allowing attacker to write arbritrary amounts of bytes.

Normally this shouldn't be possible, since the interrupt handler should never actually get WRITE_INDEX > length,
it whould only get them equal, in which case 0 bytes are read in. However, if attacker was able to switch registers without zeroing
WRITE_INDEX, they could switch from a 255 byte register after writing some bytes to a 1 byte status register.

The interrupt handler zeroes the WRITE_INDEX whenever the stop flag is set. However, i2c has a thing called repeated restart,
where you immediately start another transaction, without sending a stop, which means the stop flag is never set.

So after we sent in the 5 bytes, we send a repated restart to switch toe the RECIEVE DONE register, and then we can read in as many bytes
as we want. First, we write a smell nop sled, then shellcode to dump the entire flash over uart, and then an address in the nop sled.
Eventually this address will overwrite the pointer to the i2c handler in the interrupt vector table, meaning the next i2c interrupt will
run out shellcode.

We then have a python script listening on the uart, which reads the bytes and puts them in a file. We can then do
`strings dump.img | rg 'ectf'` to get all flags stored in plaintext, which for UCI is the pump swap, pin extract, black box extract, and black box boot.
