The reference design contains an interrupt handler on the component to enable asynchrnous receiving of i2c message.
The reference design interrupt handler has the concept of registers, where some registers are longer than others.
The send and receive data registers are 255 bytes long, but the send and receive lenght and done registers are only 1 byte long.

We exploited a flaw in the component interrupt handler. What we did is start a transaction to send data to the component.
We sent 6 bytes, and selected the recieve register, which is a large register of 255 bytes. This caused the WRITE_INDEX
variable to be incramented by 5 (since 1 byte was used to select the register). The reason we sent 6 bytes
was to trigger a recieve threshhold interrupt, which is triggered when 6 bytes are in the fxfifo.
The code for recieving bytes can be seen below:

```
int available = MXC_I2C_GetRXFIFOAvailable(I2C_INTERFACE);
if (available < (I2C_REGS_LEN[ACTIVE_REG]-WRITE_INDEX)) {
    WRITE_INDEX += MXC_I2C_ReadRXFIFO(I2C_INTERFACE,
        &I2C_REGS[ACTIVE_REG][WRITE_INDEX],
        MXC_I2C_GetRXFIFOAvailable(I2C_INTERFACE));
}
else {
    WRITE_INDEX += MXC_I2C_ReadRXFIFO(I2C_INTERFACE,
        &I2C_REGS[ACTIVE_REG][WRITE_INDEX],
        I2C_REGS_LEN[ACTIVE_REG]-WRITE_INDEX);
}
```

Since 5 data bytes were read in, this will cause WRITE_INDEX to be incramented to 5. There is an issue however,
since if `WRITE_INDEX > I2C_REGS_LEN[ACTIVE_REG]`, this will trigger the else clause to run, and
`I2C_REGS_LEN[ACTIVE_REG]-WRITE_INDEX` will be a negative number, and when passed into MXC_I2C_ReadRXFIFO as the length argument,
it will get cast to a very large unsigned value, allowing attacker to write arbritrary amounts of bytes.

Normally this shouldn't be possible, since the interrupt handler should never actually get WRITE_INDEX > length,
it whould only get them equal, in which case 0 bytes are read in. However, if attacker was able to switch registers without zeroing
WRITE_INDEX, they could switch from a 255 byte register after
